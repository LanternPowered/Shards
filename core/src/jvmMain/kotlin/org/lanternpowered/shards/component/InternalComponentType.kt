/*
 * Shards
 *
 * Copyright (c) LanternPowered <https://www.lanternpowered.org>
 * Copyright (c) contributors
 *
 * This work is licensed under the terms of the MIT License (MIT). For
 * a copy, see 'LICENSE.txt' or <https://opensource.org/licenses/MIT>.
 */
package org.lanternpowered.shards.component

import org.lanternpowered.lmbda.kt.createLambda
import org.lanternpowered.lmbda.kt.lambdaType
import org.lanternpowered.lmbda.kt.privateLookupIn
import org.lanternpowered.shards.util.AccessMode
import org.lanternpowered.shards.util.unsafeCast
import java.lang.invoke.MethodHandles
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger
import kotlin.reflect.KClass

private val idCounter = AtomicInteger()
private val lookup = ConcurrentHashMap<Class<*>, InternalComponentType<*>>()

internal actual fun <T : Component> resolveInternalComponentType(
  componentClass: KClass<T>, instantiator: (() -> T)?
): InternalComponentType<T> = resolveInternalComponentType(componentClass.java)

internal fun <T : Component> resolveInternalComponentType(
  componentClass: Class<T>
): InternalComponentType<T> = lookup.computeIfAbsent(componentClass) {
  createInternalComponentType(componentClass.kotlin)
}.unsafeCast()

private fun <T : Component> createInternalComponentType(
  componentClass: KClass<T>
): InternalComponentType<T> {
  val id = idCounter.getAndIncrement()
  val instantiator = resolveInstantiator(componentClass)
  return InternalComponentType(id, componentClass, instantiator,
    ::SimpleComponentType)
}

private class SimpleComponentType<T : Component>(
  internalType: InternalComponentType<T>, accessMode: AccessMode
) : ComponentType<T>(internalType, accessMode)

private val instantiatorType = lambdaType<() -> Any>()

/**
 * Resolves the default instantiator for the given [KClass], throws an
 * [IllegalStateException] if no default constructor is found.
 */
private fun <T : Any> resolveInstantiator(type: KClass<T>): () -> T {
  // Find the non-arg constructor, this is either manually defined,
  // default when having no constructors specified, or synthetically
  // generated by kotlin for constructors that have all default parameter
  // values (this can be private)
  val constructor = type.java.declaredConstructors
    .firstOrNull { constructor ->
      constructor.parameterCount == 0
    } ?: failNoDefaultConstructor(type)
  val lookup = MethodHandles.lookup().privateLookupIn(type)
  val handle = lookup.unreflectConstructor(constructor)
  return handle.createLambda(instantiatorType).unsafeCast()
}
